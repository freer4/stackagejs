You know how you utilize an ORM to keep your back-end in sync with your database, and easily access or manipulate that data? We're just taking that one step further. Any ORM, any SPA, mix and match if you need to, and Stackage will handle the mundane part for you. 

## What does this even do? 
Allow you to access your data models and properties directly in your Single-Page Application, including relationships and complex custom types; then automatically get that data as-needed with no further effort.

### Each back-end package will: 
1. provide standardized JS classes describing each model from your choosen ORM, such as field names, types, nullability, constraints, and relationships to other models.
2. provide standardized controller actions for basic data interaction, setting up a convention-based API from your ORM models. 

### Each front-end package will:
1. Understand the provided JS model classes to automatically interact with the API(s) as-needed. Records are accessed through proxy, so there's never a reason to write your own fetch call.  
2. Manage front-end data caching. Don't ask for data you've already gotten, unless you want to.
3. Provide optional hooks for receiving live data pushes.

### Planned front-ends: 
- stackage-js - vanilla JS holding the majority of front-end functionality for specific SPAs to wrap
- stackage-ts - same thing but with TS. Might not do this. Convince me.
- stackage-handlebars - might just be the vanilla version?
- stackage-vue
- stackage-angular
- stackage-react
- stackage-svelte

### Planned back-ends: 
- stackage-sequelize - Sequelize
- stackage-ef - Entity Framework
- Any other ORMs I come across, preferably in a variety of languages as a flex

### Other stackages: 
- Might be opportunities for invidivualized plugins based on utilities like microservices, think "PubSub". 


## API definitions
The minimum endpoints for default interactions. Created for each model on the back end, consumed by the front end. 

- [POST] /{Model.pathname}/save - Takes json output from the Model object on the front-end and creates or (updates, if PK provided) it in the database. Returns a record, including the generated PK if this was a create.
- [POST] /{Model.pathname}/save-many - Takes an array of json outputs from the Model objects on the front-end. Creates or Updates each as appropriate. Returns an array of records, including the generated PKs. 
- [POST] /{Model.pathname}/delete - Takes the id of a record to delete, returns bool
- [POST] /{Model.pathname}/delete-many - Takes an array of ids of a record to delete, returns bool
- [GET] /{Model.pathname}/{id} - Returns the record from the corresponding id
- [GET] /{Model.pathname}/list/{ids} - Returns array of records for the CSV id list provided
- [GET] /{Model.pathname}/all - Returns all available data for the given model
- [GET] /{Model.pathname}/all-ids - Returns all available ids for the given model

Model.pathname should be the model name in kebab-case by default. 


## Model definitions
The model format created by the back end for any given front end to consume.

Include a comment at the head of the file warning that this is a generated file. 
> //This file was generated by stackage, do not modify directly as your changes will be lost.

Import for the Model class. 

Imports for any related models. 

Imports for any enums.

Imports for any custom types. 

Start Class declaration extending Model.

A constructor that takes a record and a config object, calling the super(record, config) internally. 

The following static properties: 

- `prefix` Prefix option for multi-system setups. Ommitted by default.
- `name` The name of the model, which includes the prefix if any provided
- `dto` Bool indicating if this is a DTO (see DTO section)

The following static read-only function:

- `properties` function that replaces itself with the properties descriptor object. Using a function here is necessary to avoid issues with circular referencing. Returns the properties descriptor object.

The following static property. Can be omitted or empty if there are not any foreign keys: 

- `foreignKeys` KvPs in the format `fkPropertyName`: `PropertyName` //TODO determine if this is still necessary

End Class declaration.

Set a reference to the class on the window object //TODO Recall why we needed to do this...

```
window[Symbol.for(MyModel.name)] = MyModel;
```

Finally, export the model: 
`export default MyModel`

### Properties Descriptor Object
This is the object telling us all about the properties from the ORM. 

For each property: 

`propertyName` (camel case)
- `type`: an appropriate Javascript type for the property in question. Each back-end stackage will decide these default mappings. This type will determine how values are interpreted by the front-end and repackaged for the back-end as necessary. An example would be a Date type - transmitted as an ISO 8601 date value, the front-end will automatically translate this to a JS Date object for immediate use. When _out is called on this record (such as when saving) stackage will translate that value back to an ISO 8601 string value for transmission. 
Custom types can also be provided, for special data types not handled well by JS types. See Custom Data Types //TODO link
- `config`: specific configuration values that will be passed into many internal functions
  - - `nullable` (bool): whether this value is nullable. Attempting to save a non-nullable property (other than id or createdAt) without a value will generate an error.
  - - `foreignKey`: the name of the corresponding foreign key property, if this property is a relationship to another model. 

## Front-End definition

`Database` is a simple object to keep fetched data cached. Utilizing proxies, attempting to access a `Table` for the first time will create that Table on the `Database` object. 

`Table` is also a simple object, accessed from the `Database` object like so: `Database[MyModel.name]`. It utilizes proxies to create empty `Records` as they are asked for or discovered. 

`Record` is an instance of a given Model class, as they are defined from your ORM's stackage. Access a record like so: `Database[MyModel.name][PK]`. The first time a record is accessed directly, it will ask its corresponding API for the available data. There are utilities to pre-fetch at will, and re-fetch at will or with an expiration setting. 

Access related records from another record and stackage will understand what you're looking for based on the Model definitions

Empty Records are created anytime a PK is discovered for the Table. This could be as an FK from another Table or directly asked for from API.

Accessing Empty records triggers a Read call to the API. Successful retrieval updates _loaded property to true and _fetched property to current time.

If Table has a set expiration duration, the proxy remains and expiration is checked on subsequent accesses. If it does not have a set expiration, the proxy is unwrapped. 

Newly created Records are extended with non-enumerable methods and properties. 

### Record Class

#### Record properties:
- `_loaded` read-only reference to bool value indicating if record is considered loaded.
- `_busy` read-only reference to bool value representing that there is an active API call involving this Record.
- `_errors` read-only reference to error object for this record. Errors are generated by failed returns from API methods and validation callbacks. 

#### Record Local methods:
- `_remove()` removes this Record from Table, and does not call API
- `_validate()` calls each _validations function from the Table on this record
- `_addError()` adds an error to the _errors property
- `_removeError()` removes an error from the _errors property
- `_clearErrors()` removes an error from the _errors property

#### Record API methods:
- `_read()` manual trigger for Read API call, updating the Record upon success. Returns a promise.
- `_save()` calls Update API if PK is present. Calls Create API if PK is not present. Successful Create updates Record with returned PK. Returns a promise.
- `_delete()` calls Delete API. Upon Successful Delete, _remove is called on the Record. Returns a promise. 


### Table Class

#### Table properties: 
- `_array` read-only reference to const array of known records for this Table.




#### Table Local methods:
- `_remove([Record] || Record || [PK] || PK)` removes the passed Record(s) from this Table by reference or PK, and does not call API



#### Table API methods:


#### Filtration set (Optional) 

Server-side data filtering that returns an array of PKs for the given queries on this Table. Devs should be conscious of whether their data set is better filtered on the back-end (no need to send all records to client to filter) or the front-end (more data initially, but fewer network calls and less stress on the back-end). 

As these can be finicky to outright grueling to implement in an abstracted, efficient manner, at this time Filtration methods will be considered optional. 

TODO define a standard not-implemented response for the API

These properties exist on the Table:

- `_equals(prop, spec)` sets up an equals query for Filter API consumption. Returns a FilterQuery object. 
- `_contains(prop, spec)` sets up a contains query for Filter API consumption. Returns a FilterQuery object. 
- `_startsWith(prop, spec)` sets up a startsWith query for Filter API consumption. Returns a FilterQuery object. 
- `_endsWith(prop, spec)` sets up an endsWith query for Filter API consumption. Returns a FilterQuery object. 
- `_filter(filterQuery)` skips the chaining and takes a FilterQuery object directly. Calls the FilerQuery’s _go method, returns the resulting promise

FilterQuery object properties: 

- `_go()` Performs the Filter API call, or gets cashed result if present. Returns an object TODO define this object, needs promise and reference to future PK array of results.
- `_queries` array of query objects constructed for this filter
- `_subset` array of PKs in the current Table for records to restrict this filter to
- `_doRefresh` - bool indicating if a data refresh is requested, default false. If false, _go may use existing filter result if it exists
- `_refresh(bool)` - forces this query to call the API whether or not there’s a cached return for it. Returns this FilterQuery object.
- `_equals()`, `_contains()`, `_startsWith()`, and `_endWith()` methods as shortcut references to those of the same names on the Table, and return this FilterQuery object

query object format:

- `prop` a string, dot-notated path to the property being filtered on
- `spec` the value to test against

### Database Class


## Data Types

These are types that can be assigned to properties to handle special data cases not reasonably handled by default JS types. They will translate data from the API to a useable JS format interally, and back again for when the data needs sent to the API. 

They are a class with a constructor that takes a value suitable for their _value property as the first argument, and an optional config for the second. 

Required properties: 

- `_raw` is how the back-end record interacts with this data type. It has a setter that takes the raw data as provided by the API and stores it internally in a format that makes sense for JS use. Has a getter that returns the internal value in the format the API expects.
- `_value` is how the front-end record interacts with this data type. It has a setter that takes input data and transforms it into the internal value format. The getter returns the value in a format that is sensible for use. It may be that no transformation is necessary here. 

Optional properties: 

- `_validate` if this data type (not this particular data property) has a universal validation method, it should be kept here. Attempts to validate a record that contain a property with this data type will run this validator. Returns an array of errors.
- Any other properties you want

