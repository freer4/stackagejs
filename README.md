You know how you utilize an ORM to keep your back-end in sync with your database, and easily access or manipulate that data? We're just taking that one step further. Any ORM, any SPA, mix and match if you need to, and Stackage will handle the mundane part for you. 

## What does this even do? 
Allow you to access your data models and properties directly in your Single-Page Application, including relationships and complex custom types; then automatically get that data as-needed with no further effort.

### Each back-end package will: 
1. provide standardized JS classes describing each model from your choosen ORM, such as field names, types, nullability, constraints, and relationships to other models.
2. provide standardized controller actions for basic data interaction, setting up a convention-based API from your ORM models. 

### Each front-end package will:
1. Understand the provided JS model classes to automatically interact with the API(s) as-needed. Records are accessed through proxy, so there's never a reason to write your own fetch call.  
2. Manage front-end data caching. Don't ask for data you've already gotten, unless you want to.
3. Provide optional hooks for receiving live data pushes.

### Planned front-ends: 
- stackage-js - vanilla JS holding the majority of front-end functionality for specific SPAs to wrap
- stackage-ts - same thing but with TS. Might not do this. Convince me.
- stackage-handlebars - might just be the vanilla version?
- stackage-vue
- stackage-angular
- stackage-react
- stackage-svelte

### Planned back-ends: 
- stackage-sequelize - Sequelize
- stackage-ef - Entity Framework
- Any other ORMs I come across, preferably in a variety of languages as a flex

### Other stackages: 
- Might be opportunities for invidivualized plugins based on utilities like microservices, think "PubSub". 


## API definitions
The minimum endpoints for default interactions. Created for each model on the back end, consumed by the front end. 


- [POST] /{ModelName}/Save - Takes json output from the Model object on the front-end and creates or (updates, if PK provided) it in the database. Returns a record, including the generated PK if this was a create. 
- [POST] /{ModelName}/Delete - Takes the PK of a record to delete, returns bool
- [GET] /{Model}/{PK} - Returns the record from the corresponding PK
- [GET] /{Model}/List/{PKs} - Returns array of records for the CSV PK list provided
- [GET] /{Model}/All - Returns all available data for the given model

## Model definitions
The model format created by the back end for any given front end to consume.

Prefix option for multi-system setups


## Front-End definition

`Database` is a simple object to keep fetched data cached. Utilizing proxies, attempting to access a `Table` for the first time will create that Table on the `Database` object. 

`Table` is also a simple object, accessed from the `Database` object like so: `Database[MyModel.name]`. It utilizes proxies to create empty `Records` as they are asked for or discovered. 

`Record` is an instance of a given Model class, as they are defined from your ORM's stackage. Access a record like so: `Database[MyModel.name][PK]`. The first time a record is accessed directly, it will ask its corresponding API for the available data. There are utilities to pre-fetch at will, and re-fetch at will or with an expiration setting. 

Access related records from another record and stackage will understand what you're looking for based on the Model definitions

Empty Records are created anytime a PK is discovered for the Table. This could be as an FK from another Table or directly asked for from API.

Accessing Empty records triggers a Read call to the API. Successful retrieval updates _loaded property to true and _fetched property to current time.

If Table has a set expiration duration, the proxy remains and expiration is checked on subsequent accesses. If it does not have a set expiration, the proxy is unwrapped. 

Newly created Records are extended with non-enumerable methods and properties. 

### Record Class

#### Record properties:
- `_loaded` read-only reference to bool value indicating if record is considered loaded.
- `_busy` read-only reference to bool value representing that there is an active API call involving this Record.
- `_errors` read-only reference to error object for this record. Errors are generated by failed returns from API methods and validation callbacks. 

#### Record Local methods:
- `_remove()` removes this Record from Table, and does not call API
- `_validate()` calls each _validations function from the Table on this record
- `_addError()` adds an error to the _errors property
- `_removeError()` removes an error from the _errors property
- `_clearErrors()` removes an error from the _errors property

#### Record API methods:
- `_read()` manual trigger for Read API call, updating the Record upon success. Returns a promise.
- `_save()` calls Update API if PK is present. Calls Create API if PK is not present. Successful Create updates Record with returned PK. Returns a promise.
- `_delete()` calls Delete API. Upon Successful Delete, _remove is called on the Record. Returns a promise. 


### Table Class

#### Table properties: 
- `_array` read-only reference to const array of known records for this Table.




#### Table Local methods:
- `_remove([Record] || Record || [PK] || PK)` removes the passed Record(s) from this Table by reference or PK, and does not call API



#### Table API methods:


#### Filtration set (Optional) 

Server-side data filtering that returns an array of PKs for the given queries on this Table. Devs should be conscious of whether their data set is better filtered on the back-end (no need to send all records to client to filter) or the front-end (more data initially, but fewer network calls and less stress on the back-end). 

As these can be finicky to outright grueling to implement in an abstracted, efficient manner, at this time Filtration methods will be considered optional. 

TODO define a standard not-implemented response for the API

These properties exist on the Table:

- `_equals(prop, spec)` sets up an equals query for Filter API consumption. Returns a FilterQuery object. 
- `_contains(prop, spec)` sets up a contains query for Filter API consumption. Returns a FilterQuery object. 
- `_startsWith(prop, spec)` sets up a startsWith query for Filter API consumption. Returns a FilterQuery object. 
- `_endsWith(prop, spec)` sets up an endsWith query for Filter API consumption. Returns a FilterQuery object. 
- `_filter(filterQuery)` skips the chaining and takes a FilterQuery object directly. Calls the FilerQuery’s _go method, returns the resulting promise

FilterQuery object properties: 

- `_go()` Performs the Filter API call, or gets cashed result if present. Returns an object TODO define this object, needs promise and reference to future PK array of results.
- `_queries` array of query objects constructed for this filter
- `_subset` array of PKs in the current Table for records to restrict this filter to
- `_doRefresh` - bool indicating if a data refresh is requested, default false. If false, _go may use existing filter result if it exists
- `_refresh(bool)` - forces this query to call the API whether or not there’s a cached return for it. Returns this FilterQuery object.
- `_equals()`, `_contains()`, `_startsWith()`, and `_endWith()` methods as shortcut references to those of the same names on the Table, and return this FilterQuery object

query object format:

- `prop` a string, dot-notated path to the property being filtered on
- `spec` the value to test against

### Database Class


