Pick your favorite your frameworks and stack packages to abstract your ORM all the way to your HTML. Use this one convention to mix and match front-ends and back-ends however you need.  

## What will this even do? 
Each back-end package will do two things: 
1 provide standardized JS classes describing each model from your choosen ORM, such as field names, types, nullability, constraints, and relationships to other models
2 provide standardized controller actions for basic data interaction, setting up a convention-based API from your ORM models. 

Each front-end package will do :
1. Understand the provided JS model classes to automatically interact with the API(s) as-needed
2. Manage  

Planned front-ends: 
- stackage-js - vanilla JS and TS holding the majority of functionality
- stackage-handlebars - might just be the vanilla version?
- stackage-vue - wrap stackage-js to build directly into Vue reactivity
- stackage-angular - wrap stackage-js to build directly into Angular
- stackage-react - wrap stackage-js to build directly into React

Planned back-ends: 
- stackage-sequelize - Sequelize
- stackage-ef - Entity Framework



API definitions
The minimum endpoints for default interactions. Created for each model on the back end, consumed by the front end. 

Model definitions
The model format created by the back end for any given front end to consume.


Front-End definition
Models are classes provided by the back end. 

“Central” object containing references to individual “Container” objects keyed by Model name.

Container objects contain instances of known Model objects (“Records”) keyed by PKs (“id”). They are also proxies, intercepting access to Records. 

Empty Records are created anytime a PK is discovered for the Container. This could be as an FK from another Container or directly asked for from API.

If Record is accessed and PK does not exist, an empty Record of that Model is also created. 

Empty records are marked with a false _loaded property. 

Accessing Empty records triggers a Read call to the API. Successful retrieval updates _loaded property to true and _fetched property to current time.

If Container has a set expiration duration, the proxy remains and expiration is checked on subsequent accesses. If it does not have a set expiration, the proxy is unwrapped. 

Newly created Records are extended with non-enumerable methods and properties. 


Record properties:
_loaded - read-only reference to book value indicating if record is considered loaded.
_busy - read-only reference to bool value representing that there is an active API call involving this Record.
_errors - read-only reference to error object for this record. Errors are generated by failed returns from API methods and validation callbacks. 

Local Record methods:
_remove() - removes this Record from Container, and does not call API
_validate() - calls each _validations function from the Container on this record
_addError() - adds an error to the _errors property
_removeError() - removes an error from the _errors property
_clearErrors() - removes an error from the _errors property

API Record methods:
_read() - manual trigger for Read API call, updating the Record upon success. Returns a promise.
_save() - calls Update API if PK is present. Calls Create API if PK is not present. Successful Create updates Record with returned PK. Returns a promise.
_delete() - Calls Delete API. Upon Successful Delete, _remove is called on the Record. Returns a promise. 
Container properties: 
_array - read-only reference to const array of known records for this Container.

Local Container methods:



API Container methods:


Filtration set (Optional) 
Server-side data filtering that returns an array of PKs for the given queries on this container. Devs should be conscious of whether their data set is better filtered on the back-end (no need to send all records to client to filter) or the front-end (more data initially, but fewer network calls and less stress on the back-end). 

As these can be finicky to outright grueling to implement in an abstracted, efficient manner, at this time Filtration methods will be considered optional. 

TODO define a standard not-implemented response for the API

These properties exist on the Container:
_equals(prop, spec) sets up an equals query for Filter API consumption. Returns a FilterQuery object. 
_contains(prop, spec) sets up a contains query for Filter API consumption. Returns a FilterQuery object. 
_startsWith(prop, spec) sets up a startsWith query for Filter API consumption. Returns a FilterQuery object. 
_endsWith(prop, spec) sets up an endsWith query for Filter API consumption. Returns a FilterQuery object. 
_filter(filterQuery) skips the chaining and takes a FilterQuery object directly. Calls the FilerQuery’s _go method, returns the resulting promise

FilterQuery object properties: 
_go reference to the _go function
_queries array of query objects constructed for this filter
_subset array of PKs in the current Container for records to restrict this filter to
_doRefresh - bool indicating if a data refresh is requested
_refresh() - forces this query to call the API whether or not there’s a cached return for it. Returns this FilterQuery object.
_go() - Calls the Filter API with the built query. Returns a Promise.
_equals, _contains, _startsWith, and _endWith methods as shortcut references to those of the same names on the Container, and return this FilterQuery object

query object format: {
prop - a string, dot-notated path to the property being filtered on
spec - the value to test against
subset - an array of PKs in the current Container for records to restrict this filter to
}


_subset(pks) - sets the subset property on the given 


